# デザインパターン
## シングルトン パターン
### 使いどころ
 シングルトンパターンはインスタンスが1個しか生成されないことを保証したい時に使います。
 
 ### 書き方
 struct はインスタンスが一つではなくなるので、ダメ。値型だからね。
 以下の2行を書けばできる。
 ```
 static let shared =  ~~~
 private init() {}
 ```
 例：
 ```
 class MyApplication {
     // 自動的に遅延初期化される(初回アクセスのタイミングでインスタンス生成)
     static let shared = MyApplication()
     // 外部からのインスタンス生成をコンパイルレベルで禁止
     private init() {}
 }
 ```
 
 ### 参考はmonoさん
 https://medium.com/swift-column/singleton-398078bcc58d
 
 
 # クリーンアーキテクチャ
 ## 目的
 ### ソフトウェアアーキテクチャの目的は、求められるシステムを構築、保守するために必要な人材を最小限に抑えることである。
 
 
 ## 3つのプログラミングの型
 ### 関数型プログラミング
 変数が変化しない。
 可変コンポーネントと不変コンポーネントに分離させている。
 
 ### オブジェクト指向プログラミング
継承、ポリモーフィズム、カプセル化を特徴とする。

### 構造化プログラミング
goto文が老害


## 設計の原則 SOLIDの原則

### 単一責任の原則（SRP：Single Responsibility Principle）
モジュールはたった一つのアクターに対して責務を負うべきである。
モジュール → ファイルのこと。

### オープン・クローズドの原則（OCP：Opne-Closed Principle）
変更の影響を受けずにシステムを拡張しやすくすること。
目的を達成するために、システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする。
そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする。


### リスコフの置換原則（LSP：Liskov Substitution Principle）
継承の使い方の指針
ベースとなるクラスの派生系でも、ベースのものが使えるようになるべき。
アーキテクチャのレベルにも適用できる。

### インターフェイス分離の原則（ISP：Interfade Segregation Principle）
依存関係に注意する。

### 依存関係逆転の原則（DIP：Dependency Inversion Principle）
ソースコードの依存関係が（具象ではなく）抽象だけを参照しているもの
・変化しやすい具象クラスを参照しない。その代わりに、抽象インターフェイスを参照する
・変化しやすい具象クラスを継承しない。
・具象関数をオーバーライドしない
・変化しやすい具象を名指しで参照しない



